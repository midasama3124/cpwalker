#!/usr/bin/python
import rospy
import smbus 
from simple_pid import PID
from cpwalker_util.i2c_rpi import I2Cbus

from geometry_msgs.msg import Twist
from nav_msgs.msg import Odometry 

'''
Low level control for a differential drive robot with two actuated wheels (adapted from the UFES CloudWalker to the CPWalker)
 - Subscribes to the current velocity and a reference velocity (generated by a higher level controller)
 - Maps those velocities into separate wheel velocities
 - Each motor is controlled using its own PID parameters to have similar responses
 - The motors consider voltage inputs and wheel velocities in m/s
 - The object dealing with the I2C communication handles: 
        - receives as inputs the desired voltage outputs given by the PIDs
        - mapps those into (0,255) int values and output driver commands

We're using the simple-pid library, which assumes you are tunning the PID parameters in the parallel form:
C = kp*e + ki*dt*e + kd*de/dt
'''
class MotorControl(object):
    def __init__(self):
        # ROS initialization
        self.rospy = rospy
        self.rospy.init_node("motor_control_node", anonymous = True)
        self.rospy.loginfo("Starting Motor Control Node")
        
        # Start the i2c bus
        self.i2c_bus = I2Cbus()

        # Parameter initialization
        self.initParameters()

        self.initSubscribers()
        if self.debug: self.initPublishers()
        
        # Controllers initialization
        self.initPIDs()

        # Main loop
        self.main_controller()

    def __del__(self):
        self.i2c_bus.stop_robot()

    def initParameters(self):
        self.debug = self.rospy.get_param("traction_control/debug", False)

        self.control_rate = self.rospy.get_param("traction_control/control_rate", 100)
        self.rate = self.rospy.Rate(self.control_rate)
        
        '''
        I'm following the given convention for ROS topic names:
        cmd_vel: the actual velocity command (geometry_msgs.Twist)
        aux_cmd_vel: an aux velocity command that may not be suitable for the actual output (geometry_msgs.Twist)
        vel_raw: robot velocity as given by the encoders (geometry_msgs.Twist)
        odom: actual odometry readings which - ideally - consider multiple sensors (encoders and IMU, at least) (nav_msgs.Odometry)
        '''
        self.cmd_vel_topic = self.rospy.get_param("traction_general/cmd_vel_topic", "/cmd_vel")
        self.current_vel_topic = self.rospy.get_param("traction_general/vel_topic", "/vel_raw")

        self.wheels_distance = self.rospy.get_param("traction_general/wheels_distance", 0.8) # TODO: Check!

        # PID parameters for each wheel
        time_sample = 1.0/self.control_rate        
        self.controller_params_left = {
            "kp": self.rospy.get_param("traction_control/pid_params_left/P",300),
            "ki": self.rospy.get_param("traction_control/pid_params_left/I",30),
            "kd": self.rospy.get_param("traction_control/pid_params_left/D",0),
            "Ts": self.rospy.get_param("traction_control/pid_params_left/Ts",time_sample)}
        self.controller_params_right = {
            "kp": self.rospy.get_param("traction_control/pid_params_right/P",300),
            "ki": self.rospy.get_param("traction_control/pid_params_right/I",30),
            "kd": self.rospy.get_param("traction_control/pid_params_right/D",0),
            "Ts": self.rospy.get_param("traction_control/pid_params_right/Ts",time_sample)}
        
        self.reference_linear_vel = 0.0
        self.reference_angular_vel = 0.0
        self.current_linear_vel = 0.0
        self.current_angular_vel = 0.0
        return

    def initSubscribers(self):
        # Subscribe to a current vel topic and a comand vel topic
        if self.current_vel_topic == "/vel_raw":
            self.sub_vel_raw = self.rospy.Subscriber(self.current_vel_topic,Twist,self.callback_current_vel_twist)
        elif self.current_vel_topic == "/odom":
            self.sub_vel_raw = self.rospy.Subscriber(self.current_vel_topic,Odometry,self.callback_current_vel_odom)
        else:
            raise NameError('[Motor Control Node] Check the subscribers. Possible mistake on topic name')
        
        self.sub_cmd_vel = self.rospy.Subscriber(self.cmd_vel_topic,Twist,self.callback_high_level_control)
        return

    def initPublishers(self):
        self.left_control_signal = self.rospy.Publisher("left_control_signal", Int32, queue_size = 10)  
        self.right_control_signal = self.rospy.Publisher("right_control_signal", Int32, queue_size = 10)     
        return

    def initPIDs(self):
        # PID initiallization
        # Sample time equal to the control loop period
        # Output limits to keep our control signal away from the driver's +-24V boundaries (keeping it safe)
        self.pid_left  = PID(self.controller_params_left["kp"], self.controller_params_left["ki"], self.controller_params_left["kd"], setpoint=0,sample_time=self.controller_params_left["Ts"],output_limits=(-22, 22))
        self.pid_right = PID(self.controller_params_right["kp"], self.controller_params_right["ki"], self.controller_params_right["kd"], setpoint=0,sample_time=self.controller_params_right["Ts"],output_limits=(-22, 22))
        return

    def callback_high_level_control(self,msg):
        # From high level controller
        # Extract walker's reference linear and angular velocities
        self.reference_linear_vel = msg.linear.x
        self.reference_angular_vel = msg.angular.z
        return

    # I'm creating different callbacks depending on the type of velocity message expected; one of those will never be initialized
    def callback_current_vel_twist(self,msg):
        # From encoders
        # Extract walker's current linear and angular velocities
        self.current_linear_vel = msg.linear.x
        self.current_angular_vel = msg.angular.z
        return

    # I'm creating different callbacks depending on the type of velocity message expected; one of those will never be initialized
    def callback_current_vel_odom(self,msg):
        # From odometry
        # Extract walker's current linear and angular velocities
        self.current_linear_vel = msg.twist.twist.linear.x
        self.current_angular_vel = msg.twist.twist.angular.z
        return

    def vel_walker_to_wheels(self,lin,ang):
        # From walker's linear (m/s) and angular (rad/s) velocities
        # To left and right wheels velocities (m/s)
        left_wheel_vel = lin - ((ang * self.wheels_distance) / 2)
        right_wheel_vel = lin + ((ang * self.wheels_distance) / 2)
        return left_wheel_vel, right_wheel_vel

    
    # We were originally doing this: 
    '''
    def pid_controller(self, reference_vel_wheel, current_vel_wheel, wheel):
        # PID controllers
        # Get the new reference and generate the control signal
        if wheel == "left":
            self.pid_left.setpoint = reference_vel_wheel
            control_signal = self.pid_left(current_vel_wheel)
        elif wheel == "right":
            self.pid_right.setpoint = reference_vel_wheel
            control_signal = self.pid_right(current_vel_wheel)
        else:
            print("PID Error!")
        return control_signal
    '''
    # But to avoid running those IFs hundreds and hundreds of times per second, 
    # we are implementing this (minor) optmization using dedicated functions
    def pid_controller_left(self, reference_vel_wheel, current_vel_wheel):
        self.pid_left.setpoint = reference_vel_wheel
        control_signal = self.pid_left(current_vel_wheel)
        return control_signal

    def pid_controller_right(self, reference_vel_wheel, current_vel_wheel):
        self.pid_right.setpoint = reference_vel_wheel
        control_signal = self.pid_right(current_vel_wheel)
        return control_signal

    # Main loop
    def main_controller(self):
        while not self.rospy.is_shutdown():
            # get velocities for each wheel
            reference_left_wheel_vel, reference_right_wheel_vel = self.vel_walker_to_wheels(self.reference_linear_vel, self.reference_angular_vel)
            current_left_wheel_vel, current_right_wheel_vel = self.vel_walker_to_wheels(self.current_linear_vel, self.current_angular_vel)

            # Call PID (returned control signal in volts)
            left_wheel_signal_volts = self.pid_controller(reference_left_wheel_vel, current_left_wheel_vel)
            right_wheel_signal_volts = self.pid_controller(reference_right_wheel_vel, current_right_wheel_vel)

            self.i2c_bus.send_command(left_wheel_signal_volts,right_wheel_signal_volts)
            
            if self.debug == True:
                self.left_control_signal.publish(left_wheel_signal_volts)
                self.right_control_signal.publish(right_wheel_signal_volts)

            self.rate.sleep()


if __name__ == '__main__':
    try:
        mc = MotorControl()
    except rospy.ROSInterruptException:
        pass
